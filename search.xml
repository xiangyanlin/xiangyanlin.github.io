<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker Compose的使用</title>
    <url>/2020/07/07/Docker-Compose%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h4><a id="more"></a>

<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>centos安装（使用root用户或者sudo）：</p>
<p>从 <a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">官方 GitHub Release</a> 处直接下载编译好的二进制文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -L https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.26.2&#x2F;docker-compose-&#96;uname -s&#96;-&#96;uname -m&#96; &gt; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure>



<p>给予执行权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure>



<h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h3><p>编写 <code>docker-compose.yml</code> 文件，这个是 Compose 使用的主模板文件。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">tomcat:</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">tomcat</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">tomcat</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br></pre></td></tr></table></figure>





<p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p>
<p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p>
<p><code>docker-compose</code> 命令的基本的使用格式是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure>



<h2 id="命令选项"><a href="#命令选项" class="headerlink" title="#命令选项"></a><a href="https://www.funtl.com/zh/docs-docker/Docker-Compose-命令说明.html#命令选项" target="_blank" rel="noopener">#</a>命令选项</h2><ul>
<li><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</li>
<li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li>
<li><code>--x-networking</code> 使用 Docker 的可拔插网络后端特性</li>
<li><code>--x-network-driver DRIVER</code> 指定网络后端的驱动，默认为 <code>bridge</code></li>
<li><code>--verbose</code> 输出更多调试信息。</li>
<li><code>-v, --version</code> 打印版本并退出。</li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>Docker Compose</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis 缓存 的知识点</title>
    <url>/2020/02/22/Mybatis-%E7%BC%93%E5%AD%98-%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>像大多数的持久化框架一样，Mybatis 也提供了缓存策略，通过缓存策略来减少数据库的查询次数，从而提 高性能。 </p>
<a id="more"></a>

<h5 id="Mybatis-中缓存分为一级缓存，二级缓存。"><a href="#Mybatis-中缓存分为一级缓存，二级缓存。" class="headerlink" title="Mybatis 中缓存分为一级缓存，二级缓存。"></a>Mybatis 中缓存分为一级缓存，二级缓存。</h5><p><img src="https://img-blog.csdnimg.cn/20200222111725745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODg0OTcy,size_16,color_FFFFFF,t_70" alt="一级和二级缓存"></p>
<h5 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h5><p>一级缓存是 SqlSession 级别的缓存，只要 SqlSession 没有 flush 或 close，它就存在。<br>一级缓存是 SqlSession 范围的缓存，当调用 SqlSession 的修改，添加，删除，commit()，close()等</p>
<h6 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h6><p>二级缓存是 mapper 映射级别的缓存，多个 SqlSession 去操作同一个 Mapper 映射的 sql 语句，多个 SqlSession 可以共用二级缓存，二级缓存是跨 SqlSession 的</p>
<h6 id="二级缓存的开启与关闭"><a href="#二级缓存的开启与关闭" class="headerlink" title="二级缓存的开启与关闭"></a>二级缓存的开启与关闭</h6><p>2.2.2.1 第一步：在 SqlMapConfig.xml 文件开启二级缓存 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt; </span><br><span class="line"> &lt;!-- 开启二级缓存的支持 --&gt; </span><br><span class="line">  &lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;settings&gt;</span><br></pre></td></tr></table></figure>

<p>因为 cacheEnabled 的取值默认就为 true，所以这一步可以省略不配置。为 true 代表开启二级缓存；为 false 代表不开启二级缓存。 </p>
<h6 id="第二步：配置相关的-Mapper-映射文件"><a href="#第二步：配置相关的-Mapper-映射文件" class="headerlink" title="第二步：配置相关的 Mapper 映射文件"></a>第二步：配置相关的 Mapper 映射文件</h6><p><cache>标签表示当前这个 mapper 映射将使用二级缓存，区分的标准就看 mapper 的 namespace 值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line"> &lt;!DOCTYPE mapper     PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;     &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt; </span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.itheima.dao.IUserDao&quot;&gt;</span><br><span class="line"> &lt;!-- 开启二级缓存的支持 --&gt;  </span><br><span class="line"> &lt;cache&gt;&lt;&#x2F;cache&gt; </span><br><span class="line"> &lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>

<h6 id="第三步：配置-statement-上面的-useCache-属性"><a href="#第三步：配置-statement-上面的-useCache-属性" class="headerlink" title="第三步：配置 statement 上面的 useCache 属性"></a>第三步：配置 statement 上面的 useCache 属性</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 根据 id 查询 --&gt; </span><br><span class="line">&lt;select id&#x3D;&quot;findById&quot; resultType&#x3D;&quot;user&quot; parameterType&#x3D;&quot;int&quot; useCache&#x3D;&quot;true&quot;&gt;</span><br><span class="line">  select * from user where id &#x3D; #&#123;uid&#125; </span><br><span class="line">  &lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>

<p>将 UserDao.xml 映射文件中的<select>标签中设置 useCache=”true”代表当前这个 statement 要使用 二级缓存，如果不使用二级缓存可以设置为 false。 注意：针对每次查询都需要最新的数据 sql，要设置成 useCache=false，禁用二级缓存</p>
]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>14种常见的HTTP返回状态码</title>
    <url>/2019/11/17/14%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E8%BF%94%E5%9B%9E%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<p>今天学习了一下HTTP状态码，把自己的理解记录一下，如有不对之处，欢迎指正</p>
<a id="more"></a>
<h2 id="2开头：成功"><a href="#2开头：成功" class="headerlink" title="2开头：成功"></a>2开头：成功</h2><h3 id="200-ok"><a href="#200-ok" class="headerlink" title="200:ok"></a>200:ok</h3><p>成功</p>
<h3 id="204：No-Content"><a href="#204：No-Content" class="headerlink" title="204：No Content"></a>204：No Content</h3><pre><code>请求成功，但是没有东西（资源）可以返回（响应）</code></pre><h3 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206: Partial Content"></a>206: Partial Content</h3><pre><code>范围请求的成功返回状态码</code></pre><h2 id="3开头：重定向"><a href="#3开头：重定向" class="headerlink" title="3开头：重定向"></a>3开头：重定向</h2><h3 id="301：Moved-Permanently"><a href="#301：Moved-Permanently" class="headerlink" title="301：Moved Permanently"></a>301：Moved Permanently</h3><pre><code>永久性重定向。就是书签一样的</code></pre><h3 id="302：-Found"><a href="#302：-Found" class="headerlink" title="302： Found"></a>302： Found</h3><pre><code>临时性重定向。告知本次请求使用新的URL.</code></pre><h3 id="303-：See-Other"><a href="#303-：See-Other" class="headerlink" title="303 ：See Other"></a>303 ：See Other</h3><pre><code>告知请求对应的资源存在着另一个 URI，使用Get请求去访问这个新的URI.</code></pre><h3 id="304：-Not-Modified"><a href="#304：-Not-Modified" class="headerlink" title="　304： Not Modified"></a>　304： Not Modified</h3><pre><code>304 虽然被划分在 3XX 类别中，但是和重定向没有关 系。</code></pre><p>发送附带条件的请求时，资源已找到。但不满足条件。</p>
<h3 id="307：-Temporary-Redirect"><a href="#307：-Temporary-Redirect" class="headerlink" title="　307： Temporary Redirect"></a>　307： Temporary Redirect</h3><pre><code>临时重定向，该状态码与 302 Found 有着相同的含义。但是307 会遵照浏览器标准，不会从 POST 变成 GET。防止重定向时改变请求方式。</code></pre><h2 id="4开头：客户端错误"><a href="#4开头：客户端错误" class="headerlink" title="　4开头：客户端错误"></a>　4开头：客户端错误</h2><pre><code>表示发出请求的客服端发生错误</code></pre><h3 id="400：-Bad-Request"><a href="#400：-Bad-Request" class="headerlink" title="　400： Bad Request"></a>　400： Bad Request</h3><pre><code>400表示请求报文中存在语法错误。当错误发生时，需修改请求的内容。</code></pre><h3 id="401：-Unauthorized"><a href="#401：-Unauthorized" class="headerlink" title="401： Unauthorized"></a>401： Unauthorized</h3><pre><code>请求的资源需要通过认证。第一次返回401，会弹出认证用的对话窗口。第二次返回401，表示认证失败</code></pre><h3 id="403：-Forbidden"><a href="#403：-Forbidden" class="headerlink" title="　403： Forbidden"></a>　403： Forbidden</h3><pre><code>因为访问权限等问题，服务器拒绝对资源的访问，服务器在实体的主体部分说明，用户以看到该说明。</code></pre><h3 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="　404 Not Found"></a>　404 Not Found</h3><pre><code>这个出现的比较多。
该状态码表明服务器上无法找到请求的资源。
除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</code></pre><h2 id="5开头：服务器错误"><a href="#5开头：服务器错误" class="headerlink" title="5开头：服务器错误"></a>5开头：服务器错误</h2><h3 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500: Internal Server Error"></a>500: Internal Server Error</h3><pre><code>服务器端在执行请求时发生了错误。一般是代码逻辑错误，各种异常</code></pre><h3 id="503-：Service-Unavailable"><a href="#503-：Service-Unavailable" class="headerlink" title="　503 ：Service Unavailable"></a>　503 ：Service Unavailable</h3><pre><code>服务器超负荷</code></pre><h5 id="当然，也有很多时候，返回的状态码响应都是错误的，有时候代码出错也会返回200"><a href="#当然，也有很多时候，返回的状态码响应都是错误的，有时候代码出错也会返回200" class="headerlink" title="当然，也有很多时候，返回的状态码响应都是错误的，有时候代码出错也会返回200"></a>当然，也有很多时候，返回的状态码响应都是错误的，有时候代码出错也会返回200</h5><h6 id="参考阅读《HTTP图解》一书"><a href="#参考阅读《HTTP图解》一书" class="headerlink" title="参考阅读《HTTP图解》一书"></a>参考阅读《HTTP图解》一书</h6>]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile指令详解</title>
    <url>/2020/07/04/Dockerfile%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>Dockerfile的常用指令：FROM,RUN,COPY,ADD,CMD等等</p>
<a id="more"></a>



<h3 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h3><p>构建一个新的镜像是指定的基础镜像，一般为所需要的的环境</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from Java：8</span><br></pre></td></tr></table></figure>



<h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p>
<ul>
<li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello, Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span></span><br></pre></td></tr></table></figure>



<ul>
<li><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li>
</ul>
<p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:jessie</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y gcc libc6-dev make</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> wget -O redis.tar.gz <span class="string">"http://download.redis.io/releases/redis-3.2.5.tar.gz"</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> make -C /usr/src/redis</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> make -C /usr/src/redis install</span></span><br></pre></td></tr></table></figure>



<h3 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h3><p><code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</p>
<p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p>
<ul>
<li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li>
<li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li>
<li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li>
</ul>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure>



<p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$HOME</span></span></span><br></pre></td></tr></table></figure>



<p>在实际执行中，会将其变更为：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"echo <span class="variable">$HOME</span>"</span> ]</span></span><br></pre></td></tr></table></figure>



<h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><p>格式：</p>
<ul>
<li><p><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code></p>
</li>
<li><p><code>COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></p>
<p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json /usr/src/app/</span></span><br></pre></td></tr></table></figure>

<p>1</p>
<p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href="https://golang.org/pkg/path/filepath/#Match" target="_blank" rel="noopener"><code>filepath.Match</code></a> 规则，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY hom* &#x2F;mydir&#x2F;</span><br><span class="line">COPY hom?.txt &#x2F;mydir&#x2F;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p>
<p>比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。</p>
<p>另外需要注意的是，<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p>
<p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</p>
<h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code></p>
<p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p>
<h3 id="EXPOSE-暴露端口"><a href="#EXPOSE-暴露端口" class="headerlink" title="EXPOSE 暴露端口"></a>EXPOSE 暴露端口</h3><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></p>
<p><code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p>
<p><code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>格式有两种：</p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<h3 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h3><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p>
<p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p>
<p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p>
<p>在 1.13 之前的版本，要求 <code>--build-arg</code> 中的参数名，必须在 <code>Dockerfile</code> 中用 <code>ARG</code> 定义过了，换句话说，就是 <code>--build-arg</code> 指定的参数，必须在 <code>Dockerfile</code> 中使用了。如果对应参数没有被使用，则会报错退出构建。从 1.13 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 CI 系统，用同样的构建流程构建不同的 <code>Dockerfile</code> 的时候比较有帮助，避免构建命令必须根据每个 Dockerfile 的内容修改。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><ul>
<li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li>
<li><code>VOLUME &lt;路径&gt;</code></li>
</ul>
<p>之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /data</span></span><br></pre></td></tr></table></figure>



<p>这里的 <code>/data</code> 目录就会在运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -v mydata:/data xxxx</span><br></pre></td></tr></table></figure>



<p>在这行命令中，就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置。</p>
<h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h3><p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p>
<p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定</p>
<p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; <span class="string">"&lt;CMD&gt;"</span></span><br></pre></td></tr></table></figure>



<h3 id="ONBUILD-为他人作嫁衣"><a href="#ONBUILD-为他人作嫁衣" class="headerlink" title="ONBUILD 为他人作嫁衣"></a>ONBUILD 为他人作嫁衣</h3><p>格式：<code>ONBUILD &lt;其它指令&gt;</code>。</p>
<p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p>
<p><code>Dockerfile</code> 中的其它指令都是为了定制当前镜像而准备的，唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。</p>
<p>假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 <code>npm</code> 进行包管理，所有依赖、配置、启动信息等会放到 <code>package.json</code> 文件里。在拿到程序代码后，需要先进行 <code>npm install</code> 才可以获得所有需要的依赖。然后就可以通过 <code>npm start</code> 来启动应用。因此，一般来说会这样写 <code>Dockerfile</code>：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./package.json /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"install"</span> ]</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></span><br></pre></td></tr></table></figure>




<p>把这个 <code>Dockerfile</code> 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 <code>Dockerfile</code> 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。</p>
<p>如果第一个 Node.js 项目在开发过程中，发现这个 <code>Dockerfile</code> 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 <code>Dockerfile</code>，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 <code>Dockerfile</code> 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 <code>Dockerfile</code>，而第二个项目的 <code>Dockerfile</code> 就会被自动修复。</p>
<p>那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 <code>Dockerfile</code> 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 <code>Dockerfile</code> 就会变为：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></span><br></pre></td></tr></table></figure>



<p>这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 <code>my-node</code> 的话，各个项目内的自己的 <code>Dockerfile</code> 就变为：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> my-node</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./package.json /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"install"</span> ]</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app/</span></span><br></pre></td></tr></table></figure>



<p>基础镜像变化后，各个项目都用这个 <code>Dockerfile</code> 重新构建镜像，会继承基础镜像的更新。</p>
<p>那么，问题解决了么？没有。准确说，只解决了一半。如果这个 <code>Dockerfile</code> 里面有些东西需要调整呢？比如 <code>npm install</code> 都需要加一些参数，那怎么办？这一行 <code>RUN</code> 是不可能放入基础镜像的，因为涉及到了当前项目的 <code>./package.json</code>，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 <code>Dockerfile</code> 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。</p>
<p><code>ONBUILD</code> 可以解决这个问题。让我们用 <code>ONBUILD</code> 重新写一下基础镜像的 <code>Dockerfile</code>:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:slim</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="bash"> ./package.json /app</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"install"</span> ]</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="bash"> . /app/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span></span><br></pre></td></tr></table></figure>



<p>这次我们回到原始的 <code>Dockerfile</code>，但是这次将项目相关的指令加上 <code>ONBUILD</code>，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 <code>Dockerfile</code> 就变成了简单地：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> my-node</span><br></pre></td></tr></table></figure>



<p>是的，只有这么一行。当在各个项目目录中，用这个只有一行的 <code>Dockerfile</code> 构建镜像时，之前基础镜像的那三行 <code>ONBUILD</code> 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 <code>npm install</code>，生成应用镜像。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>Dockerfile</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker基础-镜像</title>
    <url>/2020/07/04/Docker%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h4 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h4><a id="more"></a>

<h5 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h5><p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>
<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<h5 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h5><p>一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>。：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br></pre></td></tr></table></figure>

<p>1</p>
<p>这个镜像原本是有镜像名和标签的，原来为 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none&gt;</code>。除了 <code>docker pull</code> 可能导致这种情况，<code>docker build</code> 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像。这类无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> ，可以用下面的命令专门显示这类镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image ls -f dangling=<span class="literal">true</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">&lt;none&gt;              &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br></pre></td></tr></table></figure>



<p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image prune</span><br></pre></td></tr></table></figure>



<h5 id="DockerFile镜像构建上下文（Context）（客户端将当前目录下内容打包传给docker引擎）"><a href="#DockerFile镜像构建上下文（Context）（客户端将当前目录下内容打包传给docker引擎）" class="headerlink" title="DockerFile镜像构建上下文（Context）（客户端将当前目录下内容打包传给docker引擎）"></a>DockerFile镜像构建上下文（Context）（客户端将当前目录下内容打包传给docker引擎）</h5><p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，因此不少初学者以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定<strong>上下文路径</strong>。那么什么是上下文呢？</p>
<p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/engine/reference/api/docker_remote_api/" target="_blank" rel="noopener">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p>
<p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p>
<p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<p>如果在 <code>Dockerfile</code> 中这么写：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> ./package.json /app/</span></span><br></pre></td></tr></table></figure>



<p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p>
<p>因此，<code>COPY</code> 这类指令中的源文件的路径都是<em>相对路径</em>。这也是初学者经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p>
<p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p>
<p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p>
<p>一般来说，应该会将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p>
<p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p>
<p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p>
<p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p>
<h2 id="其它-docker-build-的用法"><a href="#其它-docker-build-的用法" class="headerlink" title="#其它 docker build 的用法"></a><a href="https://www.funtl.com/zh/docs-docker/Docker-使用-Dockerfile-定制镜像.html#其它-docker-build-的用法" target="_blank" rel="noopener">#</a>其它 <code>docker build</code> 的用法</h2><h3 id="直接用-Git-repo-进行构建"><a href="#直接用-Git-repo-进行构建" class="headerlink" title="#直接用 Git repo 进行构建"></a><a href="https://www.funtl.com/zh/docs-docker/Docker-使用-Dockerfile-定制镜像.html#直接用-git-repo-进行构建" target="_blank" rel="noopener">#</a>直接用 Git repo 进行构建</h3><p>或许你已经注意到了，<code>docker build</code> 还支持从 URL 构建，比如可以直接从 Git repo 中构建：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build https://github.com/twang2218/gitlab-ce-zh.git<span class="comment">#:8.14</span></span><br><span class="line">docker build https://github.com/twang2218/gitlab-ce-zh.git\<span class="comment">#:8.14</span></span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM gitlab/gitlab-ce:8.14.0-ce.0</span><br><span class="line">8.14.0-ce.0: Pulling from gitlab/gitlab-ce</span><br><span class="line">aed15891ba52: Already exists</span><br><span class="line">773ae8583d14: Already exists</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>这行命令指定了构建所需的 Git repo，并且指定默认的 <code>master</code> 分支，构建目录为 <code>/8.14/</code>，然后 Docker 就会自己去 <code>git clone</code> 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 编程式事务</title>
    <url>/2019/11/21/Spring-%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>Spring 编程式事务:1 配置文件bean.xml; 2在自己的业务层方法加编程式事务</p>
<a id="more"></a>

<h4 id="1-配置文件bean-xml"><a href="#1-配置文件bean-xml" class="headerlink" title="1 配置文件bean.xml"></a>1 配置文件bean.xml</h4><p>导入相关依赖后，在配置文件bean.xml文件中配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- 配置事务管理器--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">&lt;!--这里是自己配置的数据源--&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--配置事务模板对象--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;transactionTemplate&quot; class&#x3D;&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;transactionManager&quot; ref&#x3D;&quot;transactionManager&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2在自己的业务层方法加编程式事务"><a href="#2在自己的业务层方法加编程式事务" class="headerlink" title="2在自己的业务层方法加编程式事务"></a>2在自己的业务层方法加编程式事务</h4><p>在需要加事务的方法method中书写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void method() &#123;</span><br><span class="line">        transactionTemplate.execute(new TransactionCallback&lt;Object&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object doInTransaction(TransactionStatus status) &#123;</span><br><span class="line">                ......</span><br><span class="line">                自己的方法逻辑</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 声明式事务注解@Transactional</title>
    <url>/2019/11/21/Spring-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3-Transactional/</url>
    <content><![CDATA[<p> Spring 声明式事务注解@Transactional使用的两种方式：1 结合xml配置使用； 2纯注解使用</p>
<a id="more"></a>

<h2 id="1-结合xml配置使用"><a href="#1-结合xml配置使用" class="headerlink" title="1 结合xml配置使用"></a>1 结合xml配置使用</h2><h4 id="xml配置文件中加入"><a href="#xml配置文件中加入" class="headerlink" title="xml配置文件中加入"></a>xml配置文件中加入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置事务管理器 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">&lt;!--自己配置的dataSource--&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 开启spring对注解事务的支持--&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager&#x3D;&quot;transactionManager&quot;&gt;&lt;&#x2F;tx:annotation-driven&gt;</span><br></pre></td></tr></table></figure>
<h5 id="在serivce层或者serice层的方法加-Transactional注解"><a href="#在serivce层或者serice层的方法加-Transactional注解" class="headerlink" title="在serivce层或者serice层的方法加@Transactional注解"></a>在serivce层或者serice层的方法加@Transactional注解</h5><p>参数：<br>propagation：事务传播行为<br>timeout：事务超时设置<br>isolation：事务隔离级别</p>
<h2 id="2-纯注解使用"><a href="#2-纯注解使用" class="headerlink" title="2 纯注解使用"></a>2 纯注解使用</h2><h3 id="事务管理器配置类"><a href="#事务管理器配置类" class="headerlink" title="事务管理器配置类"></a>事务管理器配置类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 和事务相关的配置类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class TransactionConfig &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 用于创建事务管理器对象</span><br><span class="line">     * @param dataSource</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Bean(name&#x3D;&quot;transactionManager&quot;)</span><br><span class="line">    public PlatformTransactionManager createTransactionManager(DataSource dataSource)&#123;</span><br><span class="line">        return new DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="service中的配置和1一样"><a href="#service中的配置和1一样" class="headerlink" title="service中的配置和1一样"></a>service中的配置和1一样</h5>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis 延迟加载和立即加载的实现</title>
    <url>/2020/01/08/mybatis-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E5%92%8C%E7%AB%8B%E5%8D%B3%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>mybatis 延迟加载和立即加载的实现</p>
<a id="more"></a>

<p> 延迟加载：   就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载.<br> 好处：先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速 度要快。<br> 坏处：   因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗 时间，所以可能造成用户等待时间变长，造成用户体验下降<br> 在我们使用多表查询时（一对一，一对多或者多对多），mybatis默认使用立即加载。如果我们想使用延迟加载需要做两件事</p>
<h3 id="1设置多表查询返回的resultMap"><a href="#1设置多表查询返回的resultMap" class="headerlink" title="1设置多表查询返回的resultMap"></a>1设置多表查询返回的resultMap</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id&#x3D;&quot;entity1tEntity2&quot; type&#x3D;&quot;entity1&quot;&gt;</span><br><span class="line">    &lt;id property&#x3D;&quot;entity1_id&quot; column&#x3D;&quot;entity1_id&quot;&gt;&lt;&#x2F;id&gt;</span><br><span class="line">    &lt;result property&#x3D;&quot;entity2_id&quot; column&#x3D;&quot;entity2_id&quot;&gt;&lt;&#x2F;result&gt;&lt;!--关联字段--&gt;</span><br><span class="line">    &lt;result property&#x3D;&quot;file&quot; column&#x3D;&quot;file&quot;&gt;&lt;&#x2F;result&gt;</span><br><span class="line">        &lt;!--在这里完成这个配置后只要select * from table_entity1就可以了--&gt;</span><br><span class="line">    &lt;!-- 一对一的关系映射：配置封装entity2的内容</span><br><span class="line">    select属性指定的内容：查询entity2的唯一标识：</span><br><span class="line">    column属性指定的内容：entity2根据id查询时，所需要的参数的值</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;association property&#x3D;&quot;entity2&quot; column&#x3D;&quot;entity2_id&quot; javaType&#x3D;&quot;entity2&quot; select&#x3D;&quot;namespce+查询语句的id&quot;&gt;&lt;&#x2F;association&gt;</span><br><span class="line">        &lt;!--在这里完成这个配置后只要select * from table_entity1 where entity2_id&#x3D;?就可以了--&gt;</span><br><span class="line">&lt;&#x2F;resultMap&gt;</span><br></pre></td></tr></table></figure>
<p>配置映射文件config.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">        &lt;!--开启Mybatis支持延迟加载--&gt;</span><br><span class="line">        &lt;setting name&#x3D;&quot;lazyLoadingEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;settings&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<p>官方文档：<a href="https://mybatis.org/mybatis-3/zh/configuration.html#settings" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/configuration.html#settings</a>.<br><img src="https://img-blog.csdnimg.cn/20200108220513576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODg0OTcy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title> mybatic初学环境搭建</title>
    <url>/2019/11/19/mybatic%E5%88%9D%E5%AD%A6%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>搭建mybatis环境</p>
<a id="more"></a>

<h3 id="1-maven导入相关依赖"><a href="#1-maven导入相关依赖" class="headerlink" title="1 maven导入相关依赖"></a>1 maven导入相关依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;!--mybatic--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.4.5&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--mysql连接--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.6&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!--日志--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.12&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">               &lt;!--junit测试--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.10&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-配置mybaits的配置文件SqlMapConfig-xml"><a href="#2-配置mybaits的配置文件SqlMapConfig-xml" class="headerlink" title="2 配置mybaits的配置文件SqlMapConfig.xml"></a>2 配置mybaits的配置文件SqlMapConfig.xml</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;!-- mybatis的主配置文件 --&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!-- 配置环境 --&gt;</span><br><span class="line">    &lt;environments default&#x3D;&quot;mysql&quot;&gt;</span><br><span class="line">        &lt;!-- 配置mysql的环境--&gt;</span><br><span class="line">        &lt;environment id&#x3D;&quot;mysql&quot;&gt;</span><br><span class="line">            &lt;!-- 配置事务的类型--&gt;</span><br><span class="line">            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&gt;&lt;&#x2F;transactionManager&gt;</span><br><span class="line">            &lt;!-- 配置数据源（连接池） --&gt;</span><br><span class="line">            &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;!-- 配置连接数据库的4个基本信息 --&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;1234&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;dataSource&gt;</span><br><span class="line">        &lt;&#x2F;environment&gt;</span><br><span class="line">    &lt;&#x2F;environments&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource&#x3D;&quot;com&#x2F;itheima&#x2F;dao&#x2F;IUserDao.xml&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;mappers&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3-创建数据库表对应的实体"><a href="#3-创建数据库表对应的实体" class="headerlink" title="3 创建数据库表对应的实体"></a>3 创建数据库表对应的实体</h3><h3 id="4-创建SqlMapConfig-xml对应的映射文件"><a href="#4-创建SqlMapConfig-xml对应的映射文件" class="headerlink" title="4 创建SqlMapConfig.xml对应的映射文件"></a>4 创建SqlMapConfig.xml对应的映射文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">        &lt;!DOCTYPE mapper</span><br><span class="line">                PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">                &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">                &lt;!--****是对应的dao层接口--&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;****&quot;&gt;</span><br><span class="line">&lt;!--这里写自己的动态sql--&gt;</span><br><span class="line">.......</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure>
<h5 id="5-写好自己的dao层接口，以及运行，读取SqlMapConfig-xml"><a href="#5-写好自己的dao层接口，以及运行，读取SqlMapConfig-xml" class="headerlink" title="5 写好自己的dao层接口，以及运行，读取SqlMapConfig.xml"></a>5 写好自己的dao层接口，以及运行，读取SqlMapConfig.xml</h5>]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title> mysql联合主键</title>
    <url>/2020/01/07/mysql%E8%81%94%E5%90%88%E4%B8%BB%E9%94%AE/</url>
    <content><![CDATA[<p> mysql联合主键</p>
<a id="more"></a>

<p>把（列名1，列名2）设置联合主键。将其看成一个有序对。这个有序对不能重复！就是不能有两条记录列名1，列名2都是一样的。</p>
<p>添加语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name ADD CONSTRAINT 别名 PRIMARY KEY(列名1，列名2)；</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>项目启动报错</title>
    <url>/2020/05/15/org-xml-sax-SAXNotRecognizedException-Feature-http-apache-org-xml-features-val/</url>
    <content><![CDATA[<p>导入一个web项目，跑起来的时候报”org.xml.sax.SAXNotRecognizedException:Feature:<a href="http://apache.org/xml/features/val”。原因：原项目用的是jdk1.7而现在用的是1.8.换成jdk1.7后成功运行" target="_blank" rel="noopener">http://apache.org/xml/features/val”。原因：原项目用的是jdk1.7而现在用的是1.8.换成jdk1.7后成功运行</a></p>
]]></content>
      <categories>
        <category>jdk</category>
      </categories>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/06/16/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>sql获取当前插入表的id</title>
    <url>/2019/12/05/sql%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%8F%92%E5%85%A5%E8%A1%A8%E7%9A%84id/</url>
    <content><![CDATA[<p> sql获取当前插入表的id</p>
<a id="more"></a>

<p>sql语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select last_insert_id();</span><br></pre></td></tr></table></figure>

<p>动态sql:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;selectKey keyProperty&#x3D;&quot;userId&quot; keyColumn&#x3D;&quot;id&quot; resultType&#x3D;&quot;int&quot; order&#x3D;&quot;AFTER&quot;&gt;</span><br><span class="line">    select last_insert_id();</span><br><span class="line">&lt;&#x2F;selectKey&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>swaggerv1接口文档UI界面的方法点不开，只能点统一展开，关闭</title>
    <url>/2019/12/05/swagger%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3UI%E7%95%8C%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95%E7%82%B9%E4%B8%8D%E5%BC%80%EF%BC%8C%E5%8F%AA%E8%83%BD%E7%82%B9%E7%BB%9F%E4%B8%80%E5%B1%95%E5%BC%80%EF%BC%8C%E5%85%B3%E9%97%AD/</url>
    <content><![CDATA[<p> swagger接口文档UI界面的方法点不开，只能点统一展开，关闭<br>解决方法：将@Api(value=””)注解里面的中文换成英文，成功点开每个方法<br><img src="https://img-blog.csdnimg.cn/20191205100059614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODg0OTcy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>swagger</category>
      </categories>
      <tags>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis连接池的3种配置方式</title>
    <url>/2019/12/11/mybatis%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%843%E7%A7%8D%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p> mybatis连接池的3种配置方式:1,POOLED; 2,UNPOOLED 3,JNDI</p>
<a id="more"></a>

<h4 id="1-POOLED"><a href="#1-POOLED" class="headerlink" title="1,POOLED"></a>1,POOLED</h4><p>采用传统的javax. sql. DataSource规范中的连接池.一旦数据库操作完成，mybaties会将此连接返回给连接池。mybatis有实现规范。<br>SqlMapConfig.xml中的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">              &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">              &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">              &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">              &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">          &lt;&#x2F;dataSource&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-UNPOOLED"><a href="#2-UNPOOLED" class="headerlink" title="2,UNPOOLED"></a>2,UNPOOLED</h4><p>采用传统的获取连接的方式，同样实现Javax. sql. DataSourcel，不过没有使用池的思想。也就是说mybaties会为每一个数据库操作创建一个新的连接，使用完就关闭它。<br>SqlMapConfig.xml中的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dataSource type&#x3D;&quot;UNPOOLED&quot;&gt;</span><br><span class="line">              &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">              &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">              &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">              &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">          &lt;&#x2F;dataSource&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-JNDI"><a href="#3-JNDI" class="headerlink" title="3,JNDI"></a>3,JNDI</h4><p>  是SUN公司推出的一套规范，属于JavaEE技术之一。目的是模仿windows系统中的注册表。采用服务器提供的JNDI技术实现，来获取DataSource对 象，不同的服务器所能拿到DataSource是不一样。<br>  mybaties会从在应用服务器向配置好的JNDI数据源DataSource获取数据库连接。一般在生产环境中使用。<br>  SqlMapConfig.xml中的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;environments default&#x3D; &quot;mysql&quot;&gt;</span><br><span class="line">&lt;environment id&#x3D; &quot;mysql&quot;&gt;</span><br><span class="line">&lt;transact ionManager type &#x3D;”JDBC&quot;&gt;&lt; &#x2F; transact ionManager&gt;</span><br><span class="line">&lt;dataSource type&#x3D; ”JNDI&quot; &gt;</span><br><span class="line">&lt; property name&#x3D; ”data_ source&quot; value&#x3D; &quot;java : comp&#x2F; env&#x2F; jdbc&#x2F;数据库名</span><br><span class="line">&lt;&#x2F;dataSource&gt;</span><br><span class="line">&lt; &#x2F;environment&gt;</span><br><span class="line">&lt; &#x2F; environments&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;Context&gt;</span><br><span class="line"></span><br><span class="line">&lt;Resource </span><br><span class="line">name&#x3D;&quot;jdbc&#x2F;test&quot;                  数据源的名称</span><br><span class="line">type&#x3D;&quot;javax.sql.DataSource&quot;                   数据源类型</span><br><span class="line">auth&#x3D;&quot;Container&quot;                        数据源提供者</span><br><span class="line">maxActive&#x3D;&quot;20&quot;                         最大活动数</span><br><span class="line">maxWait&#x3D;&quot;10000&quot;                            最大等待时间</span><br><span class="line">maxIdle&#x3D;&quot;5&quot;                               最大空闲数</span><br><span class="line">username&#x3D;&quot;root&quot;                            用户名</span><br><span class="line">password&#x3D;&quot;1234&quot;                            密码</span><br><span class="line">driverClassName&#x3D;&quot;com.mysql.jdbc.Driver&quot;          驱动类</span><br><span class="line">url&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;eesy_mybatis&quot; 连接url字符串</span><br><span class="line">&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>在resouce的目录下：<br>写一个配置文件：context.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Resource </span><br><span class="line">name&#x3D;&quot;jdbc&#x2F;test&quot;</span><br><span class="line">type&#x3D;&quot;javax.sql.DataSource&quot;</span><br><span class="line">auth&#x3D;&quot;Container&quot;</span><br><span class="line">maxActive&#x3D;</span><br><span class="line">maxWait&#x3D;</span><br><span class="line">maxIdle&#x3D;</span><br><span class="line">username&#x3D;</span><br><span class="line">password&#x3D;</span><br><span class="line">driverClassName&#x3D;&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">url&#x3D;</span><br><span class="line">&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Context&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis表间关系，多表联查如何定义实体和返回类型</title>
    <url>/2019/12/17/mybatis%E8%A1%A8%E9%97%B4%E5%85%B3%E7%B3%BB%EF%BC%8C%E5%A4%9A%E8%A1%A8%E8%81%94%E6%9F%A5%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%AE%9E%E4%BD%93%E5%92%8C%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p> mybatis表间关系，多表联查如何定义实体和返回类型</p>
<a id="more"></a>

<h3 id="1，一对一关系在实体加入关联实体属性-Entity1-和Entity2一对一-通过field关联"><a href="#1，一对一关系在实体加入关联实体属性-Entity1-和Entity2一对一-通过field关联" class="headerlink" title="1，一对一关系在实体加入关联实体属性(Entity1 和Entity2一对一,通过field关联)"></a>1，一对一关系在实体加入关联实体属性(Entity1 和Entity2一对一,通过field关联)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Entity1 implements Serializable &#123;</span><br><span class="line">private Integer id;</span><br><span class="line">private String field;</span><br><span class="line">private String field1;</span><br><span class="line">private Entity2 entity2;</span><br><span class="line">(getter,setter,toString方法)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">public class Entity2 implements Serializable &#123;</span><br><span class="line">private Integer id;</span><br><span class="line">private String field;</span><br><span class="line">private String field2;</span><br><span class="line">private Entity2 entity1;</span><br><span class="line">(getter,setter,toString方法)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Entity1对应的mapper中加入相应的resultMap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id&#x3D;&quot;entity1Entity2Map&quot; type&#x3D;&quot;Entity1 &quot;&gt;</span><br><span class="line">    &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;aid&quot;&gt;&lt;&#x2F;id&gt;</span><br><span class="line">    &lt;result property&#x3D;&quot;field&quot; column&#x3D;&quot;field&quot;&gt;&lt;&#x2F;result&gt;</span><br><span class="line">    &lt;result property&#x3D;&quot;field1&quot; column&#x3D;&quot;field1&quot;&gt;&lt;&#x2F;result&gt;</span><br><span class="line">    &lt;!-- 一对一的关系映射：配置封装Entity2的内容--&gt;</span><br><span class="line">    &lt;association property&#x3D;&quot;field&quot; column&#x3D;&quot;field&quot; javaType&#x3D;&quot;Entity2&quot;&gt;</span><br><span class="line">        &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&gt;&lt;&#x2F;id&gt;</span><br><span class="line">        &lt;result column&#x3D;&quot;field&quot; property&#x3D;&quot;field&quot;&gt;&lt;&#x2F;result&gt;</span><br><span class="line">        &lt;result column&#x3D;&quot;field2&quot; property&#x3D;&quot;field2&quot;&gt;&lt;&#x2F;result&gt;</span><br><span class="line">    &lt;&#x2F;association&gt;</span><br><span class="line">&lt;&#x2F;resultMap&gt;</span><br></pre></td></tr></table></figure>
<p>2，一对多关系在实体加入关联实体属性(Entity3 和Entity4一对多,通过field关联)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Entity3 implements Serializable &#123;</span><br><span class="line">private Integer id;</span><br><span class="line">private String field;</span><br><span class="line">private String field3;</span><br><span class="line">private List&lt;Entity4&gt; entity4;</span><br><span class="line">(getter,setter,toString方法)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">public class Entity2 implements Serializable &#123;</span><br><span class="line">private Integer id;</span><br><span class="line">private String field;</span><br><span class="line">private String field4;</span><br><span class="line">private Entity2 entity3;</span><br><span class="line">(getter,setter,toString方法)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Entity3对应的mapper中加入相应的resultMap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id&#x3D;&quot;entity3Entity4Map&quot; type&#x3D;&quot;Entity3 &quot;&gt;</span><br><span class="line">    &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;aid&quot;&gt;&lt;&#x2F;id&gt;</span><br><span class="line">    &lt;result property&#x3D;&quot;field&quot; column&#x3D;&quot;field&quot;&gt;&lt;&#x2F;result&gt;</span><br><span class="line">    &lt;result property&#x3D;&quot;field3&quot; column&#x3D;&quot;field3&quot;&gt;&lt;&#x2F;result&gt;</span><br><span class="line">    &lt;!-- 配置Entity3对象中Entity4集合的映射 --&gt;</span><br><span class="line">    &lt;collection property&#x3D;&quot;Entity4&quot; ofType&#x3D;&quot;Entity4&quot;&gt;</span><br><span class="line">        &lt;id column&#x3D;&quot;id&quot; property&#x3D;&quot;id&quot;&gt;&lt;&#x2F;id&gt;</span><br><span class="line">        &lt;result column&#x3D;&quot;field&quot; property&#x3D;&quot;field&quot;&gt;&lt;&#x2F;result&gt;</span><br><span class="line">        &lt;result column&#x3D;&quot;field4&quot; property&#x3D;&quot;field4&quot;&gt;&lt;&#x2F;result&gt;</span><br><span class="line">    &lt;&#x2F;collection&gt;</span><br><span class="line">&lt;&#x2F;resultMap&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3，多对多关系"><a href="#3，多对多关系" class="headerlink" title="3，多对多关系"></a>3，多对多关系</h3><p>多对多关系就类似了，实体（Entity5，Entity6关联）中都是加对方的List<T><br>ReultMap关对方联集合的映射</p>
]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>windows下升级node.js, 在cmd 运行n stable报错bash不是内部或外部命令，也不是可运行的程序 或批处理文件</title>
    <url>/2020/01/08/windows%E4%B8%8B%E5%8D%87%E7%BA%A7node-js-%E5%9C%A8cmd-%E8%BF%90%E8%A1%8Cn-stable%E6%8A%A5%E9%94%99bash%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E6%88%96%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%B9%9F%E4%B8%8D%E6%98%AF%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F-%E6%88%96%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>windows下升级node.js, 在cmd 运行n stable报错bash不是内部或外部命令，也不是可运行的程序 或批处理文件。</p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20200108102152449.png" alt="在这里插入图片描述"><br>在GitHub官网，搜索gnvm，下载<br><img src="https://img-blog.csdnimg.cn/20200108102414994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODg0OTcy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200108102504659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODg0OTcy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>放在node.js的安装目录下</p>
<p><img src="https://img-blog.csdnimg.cn/20200108102646281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODg0OTcy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后打开cmd命令行窗口，输入：gnvm update latest，等待更新。<br>当然也可以直接覆盖.<br>参考文章：<br><a href="https://jingyan.baidu.com/album/9158e000fc556ea2541228e2.html?picindex=1" target="_blank" rel="noopener">https://jingyan.baidu.com/album/9158e000fc556ea2541228e2.html?picindex=1</a>.</p>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>使用dhcp始终无法连接mysql的问题解决</title>
    <url>/2019/11/21/%E4%BD%BF%E7%94%A8dhcp%E5%A7%8B%E7%BB%88%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5mysql%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>把mysql的时区加8</p>
<a id="more"></a>

<p>把mysql的时区加8</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global time_zone &#x3D; &#39;+8:00&#39;;</span><br></pre></td></tr></table></figure>

<p>参考链接：<br><a href="https://blog.csdn.net/zqb765720343/article/details/80076020" target="_blank" rel="noopener">https://blog.csdn.net/zqb765720343/article/details/80076020:</a></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql删除database报错ERROR 1010 (HY000): Error dropping database (can&#39;t rmdir &#39;./library&#39;, errno:</title>
    <url>/2020/02/27/mysql%E5%88%A0%E9%99%A4database%E6%8A%A5%E9%94%99ERROR-1010-HY000-Error-dropping-database-can-t-rmdir-library-errno/</url>
    <content><![CDATA[<h3 id="数据库删除报错：ERROR-1010-HY000-Error-dropping-database-can’t-rmdir-‘-library’-errno"><a href="#数据库删除报错：ERROR-1010-HY000-Error-dropping-database-can’t-rmdir-‘-library’-errno" class="headerlink" title="数据库删除报错：ERROR 1010 (HY000): Error dropping database (can’t rmdir ‘./library’, errno:"></a>数据库删除报错：ERROR 1010 (HY000): Error dropping database (can’t rmdir ‘./library’, errno:</h3><p>‘./library’删除的数据库文件夹下面还有东西，需要手动删除。<br>参考文章:<a href="https://www.cnblogs.com/ivictor/p/5917370.html" target="_blank" rel="noopener">https://www.cnblogs.com/ivictor/p/5917370.html</a>.</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>区分项目中的数据实体目录 entity，dto,vo</title>
    <url>/2020/03/06/%E5%8C%BA%E5%88%86%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AE%9E%E4%BD%93%E7%9B%AE%E5%BD%95-entity%EF%BC%8Cdto-vo/</url>
    <content><![CDATA[<p>1、entity 里的每一个字段，与数据库相对应，<br>2、vo 里的每一个字段，是和你前台 html 页面相对应，<br>3、dto 这是用来转换从 entity 到 vo，或者从 vo 到 entity 的中间的东西 。（DTO中拥有的字段应该是entity中或者是vo中的一个子集）<br><a href="https://www.cnblogs.com/vegetableDD/p/11732495.html" target="_blank" rel="noopener">参考文章：https://www.cnblogs.com/vegetableDD/p/11732495.html</a></p>
]]></content>
      <categories>
        <category>java规范</category>
      </categories>
      <tags>
        <tag>java规范</tag>
      </tags>
  </entry>
  <entry>
    <title>使用eclipse导入myeclipse项目无法识别为web项目问题的解决</title>
    <url>/2020/05/15/%E4%BD%BF%E7%94%A8eclipse%E5%AF%BC%E5%85%A5myeclipse%E9%A1%B9%E7%9B%AE%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB%E4%B8%BAweb%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>原因eclipse默认的web目录为webcontent,而myeclipse的为webRoot,导致无法识别</p>
<a id="more"></a>

<p>解决办法：<br>在eclipse中右击项目根路径，在弹出的对话框中，选择 Properties：<img src="https://img-blog.csdnimg.cn/2020051522170285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODg0OTcy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>选择 Project Facets，点击右边的“Convert to faceted form…”链接：<br><img src="https://img-blog.csdnimg.cn/20200515222409927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODg0OTcy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>勾选 Java 和 Dynamic Web Module ：<br><img src="https://img-blog.csdnimg.cn/20200515222615606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODg0OTcy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>点击“ Further Configuration availabe ” 的链接 ，更改 Content Directory 名字为你的 webRoot 目录名字即可</p>
]]></content>
      <categories>
        <category>eclipse</category>
      </categories>
      <tags>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>《thinking in java》读书笔记</title>
    <url>/2019/12/02/%E3%80%8Athinking-in-java%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>记录今天一些学习《JAVA编程思想》中读到的让我深思和值得记录的点</p>
<a id="more"></a>

<p> 1，每个对象对可以很好的完成一项任务，但它并不试图做更多的事情<br> 2，继承：is-a,接口：is-like-a<br> 3，前期绑定：编译器对具体的函数调用<br>      后期绑定：编译器不知道具体执行的代码。只确定被调用的方法存在，（y用一段特殊的代码代替具体方法的绝对地址调用）到执行时才确定。<br> 4，参数化类型：<type>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;User&gt; users&#x3D;new ArrayList&lt;User&gt;;</span><br></pre></td></tr></table></figure>
<p>applet:只在浏览器中运行的小程序。<br>Intranet:企业内部网</p>
]]></content>
      <categories>
        <category>读书笔记 - thinKing in java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《thinking in java》读书笔记2：对象</title>
    <url>/2019/12/04/%E3%80%8Athinking-in-java%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02%EF%BC%9A%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>BigInteger:支持任意精度的整数<br>BigDecimal:支持任何精度的定点数<br>java的作用域由{ }决定，</p>
<a id="more"></a>

<h4 id="java基本成员变量默认值"><a href="#java基本成员变量默认值" class="headerlink" title="java基本成员变量默认值"></a>java基本成员变量默认值</h4><p>boolean:false, char：’\u0000’(null), byte:0, short: 0, int：0，long: 0L, float: 0.0f, double:0.0d</p>
<h4 id="javadoc"><a href="#javadoc" class="headerlink" title="javadoc"></a>javadoc</h4><p>javadoc 命令只能出现在”/**”注释中出现，主要有两种方式。<br>1，文档标签,<br>（1）独立文档标签：以”@”开头<br> （2）行内文档标签：同样以”@”开头，但是要括在”{}”内。<br>2，嵌入html<br>如: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">*&lt;ol&gt;</span><br><span class="line">*&lt;li&gt;item one</span><br><span class="line">*&lt;&#x2F;ol&gt;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>读书笔记 - thinKing in java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>在学Spring Aop 发现的注意点</title>
    <url>/2019/11/18/%E5%9C%A8%E5%AD%A6Spring-Aop-%E5%8F%91%E7%8E%B0%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
    <content><![CDATA[<h2 id="基于xml"><a href="#基于xml" class="headerlink" title="基于xml"></a>基于xml</h2><p>有两种方式可以实现：1环绕通知; 2前置通知，后置通知，最终通知，异常通知</p>
<a id="more"></a>

<h3 id="1环绕通知"><a href="#1环绕通知" class="headerlink" title="1环绕通知"></a>1环绕通知</h3><p>配置环绕通知</p>
<h3 id="2前置通知，后置通知，最终通知，异常通知"><a href="#2前置通知，后置通知，最终通知，异常通知" class="headerlink" title="2前置通知，后置通知，最终通知，异常通知"></a>2前置通知，后置通知，最终通知，异常通知</h3><!--配置aop-->
<pre><code>&lt;aop:config&gt;
    &lt;!--切入点表达式--&gt;
    &lt;aop:pointcut id=&quot;pr&quot; expression=&quot;execution(作用范围)&quot;&gt;&lt;/aop:pointcut&gt;
    &lt;aop:aspect id=&quot;txAdvice&quot; ref=&quot;txManager&quot;&gt;
        &lt;!--前置通知--&gt;
        &lt;aop:before method=&quot;beginTransaction&quot; pointcut-ref=&quot;pr&quot;&gt;&lt;/aop:before&gt;
        &lt;!--后置通知--&gt;
        &lt;aop:after-returning method=&quot;commit&quot; pointcut-ref=&quot;pr&quot;&gt;&lt;/aop:after-returning&gt;
        &lt;!--异常通知--&gt;
        &lt;aop:after-throwing method=&quot;rollback&quot; pointcut-ref=&quot;pr&quot;&gt;&lt;/aop:after-throwing&gt;
        &lt;!--最终通知--&gt;
        &lt;aop:after method=&quot;release&quot; pointcut-ref=&quot;pr&quot;&gt;&lt;/aop:after&gt;
    &lt;/aop:aspect&gt;

&lt;/aop:config&gt;</code></pre><h3 id="基于注解"><a href="#基于注解" class="headerlink" title="基于注解"></a>基于注解</h3><p>只能使用环绕通知<br>如果使用前置通知，后置通知，最终通知，异常通知会因为执行顺序问题导致错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Around(&quot;pt1()&quot;)</span><br><span class="line">   public Object aroundAdvice(ProceedingJoinPoint pjp)&#123;</span><br><span class="line">       Object rtValue &#x3D; null;</span><br><span class="line">       try &#123;</span><br><span class="line">           &#x2F;&#x2F;1.获取参数</span><br><span class="line">           Object[] params &#x3D; pjp.getParams();</span><br><span class="line">           &#x2F;&#x2F;2.开启事务</span><br><span class="line">           this.beginTransaction();</span><br><span class="line">           &#x2F;&#x2F;3.执行方法</span><br><span class="line">           rtValue &#x3D; pjp.proceed(params);</span><br><span class="line">           &#x2F;&#x2F;4.提交事务</span><br><span class="line">           this.commit();</span><br><span class="line">           &#x2F;&#x2F;返回结果</span><br><span class="line">           return  rtValue;</span><br><span class="line">       &#125;catch (Throwable e)&#123;</span><br><span class="line">           &#x2F;&#x2F;5.回滚事务</span><br><span class="line">           this.rollback();</span><br><span class="line">           throw new RuntimeException(e);</span><br><span class="line">       &#125;finally &#123;</span><br><span class="line">           &#x2F;&#x2F;6.释放资源</span><br><span class="line">           this.release();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>戴尔惠普华硕笔记本Fn键反了，按F1、F2等键出来Fn+F1、F2的效果</title>
    <url>/2020/03/02/%E6%88%B4%E5%B0%94%E6%83%A0%E6%99%AE%E5%8D%8E%E7%A1%95%E7%AC%94%E8%AE%B0%E6%9C%ACFn%E9%94%AE%E5%8F%8D%E4%BA%86%EF%BC%8C%E6%8C%89F1%E3%80%81F2%E7%AD%89%E9%94%AE%E5%87%BA%E6%9D%A5Fn-F1%E3%80%81F2%E7%9A%84%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>惠普笔记本，几天按f12调试的时候，笔记本直接睡眠了，试验了一番发现Fn键反了按F12等键出来Fn+F2的效果，按F1到F12等键出来Fn+F1到F12的效果。在网上寻找一番答案发现是是fn键被锁住了。<br>找到键盘上的一个Fnlock（缩写FnLk）或Numlock键，然后按Fn+Fnlock/Numlock解锁<br><a href="https://jingyan.baidu.com/article/ff41162594df7f12e48237ee.html" target="_blank" rel="noopener">参考文章:<br>https://jingyan.baidu.com/article/ff41162594df7f12e48237ee.html</a>.</p>
]]></content>
      <categories>
        <category>电脑问题 - 键盘</category>
      </categories>
      <tags>
        <tag>键盘</tag>
      </tags>
  </entry>
  <entry>
    <title> 阿里云centos7 运行tomcat 之后远程无法访问的解决</title>
    <url>/2020/01/17/%E9%98%BF%E9%87%8C%E4%BA%91centos7-%E8%BF%90%E8%A1%8Ctomcat-%E4%B9%8B%E5%90%8E%E8%BF%9C%E7%A8%8B%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>在安装好 jdk tomcat,并且配好环境变量之后返现远程通过8080无法访问<br>解决方法如下：</p>
<a id="more"></a>

<h4 id="1-查看在服务器本地是否能够访问"><a href="#1-查看在服务器本地是否能够访问" class="headerlink" title="1 查看在服务器本地是否能够访问"></a>1 查看在服务器本地是否能够访问</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -i http:&#x2F;&#x2F;localhost:8080</span><br></pre></td></tr></table></figure>
<p>看一下有没有数据返回，比较慢可能需要等待几分钟时间</p>
<h4 id="2-添加安全组规则"><a href="#2-添加安全组规则" class="headerlink" title="2 添加安全组规则"></a>2 添加安全组规则</h4><p>在阿里云的控制添加安全组规则：<br><img src="https://img-blog.csdnimg.cn/20200117145259792.png" alt="在这里插入图片描述"></p>
<h3 id="3在服务器放开放防火墙firewall端口"><a href="#3在服务器放开放防火墙firewall端口" class="headerlink" title="3在服务器放开放防火墙firewall端口"></a>3在服务器放开放防火墙firewall端口</h3><p>查看8080在firewall是否开启。发现没有开启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> firewall-cmd --query-port&#x3D;8080&#x2F;tcp</span><br><span class="line">no</span><br></pre></td></tr></table></figure>
<p>添加8080</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port&#x3D;8080&#x2F;tcp --permanent</span><br></pre></td></tr></table></figure>
<p>重新载入防火墙</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<p>查询8080端口是否开启成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --query-port&#x3D;8080&#x2F;tcp</span><br></pre></td></tr></table></figure>
<p>参考文章：<br><a href="https://blog.csdn.net/realjh/article/details/82048492" target="_blank" rel="noopener">Linux下Centos7对外开放端口：</a><br><a href="https://blog.csdn.net/realjh/article/details/82048492" target="_blank" rel="noopener">https://blog.csdn.net/realjh/article/details/82048492</a></p>
]]></content>
      <categories>
        <category>linux - centos</category>
      </categories>
      <tags>
        <tag>阿里云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链和Hyperledger Fabric入门</title>
    <url>/2020/07/09/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%92%8CHyperledger-Fabric%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h4 id="什么是区块链"><a href="#什么是区块链" class="headerlink" title="什么是区块链"></a>什么是区块链</h4><h5 id="一个分布式账本"><a href="#一个分布式账本" class="headerlink" title="一个分布式账本"></a>一个分布式账本</h5><p>区块链网络的核心是一个分布式账本，记录网络上发生的所有交易。</p>
<p>区块链账本通常被描述为 <strong>去中心化的</strong> ，因为它会被复制到许多网络参与者中，每个参与者都在 <strong>协作</strong> 维护账本。我们将看到去中心化和协作是强大的属性，反映了企业在现实世界中交换商品和服务的方式。</p>
<p><strong>去中心化</strong>：在一个分布有众多节点的系统中，每个节点都具有高度自治的特征。节点之间彼此可以自由连接，形成新的连接单元。任何一个节点都可能成为阶段性的中心，但不具备强制性的中心控制功能。节点与节点之间的影响，会通过网络而形成非线性因果关系。这种开放式、扁平化、平等性的系统现象或结构，我们称之为去中心化。</p>
<h5 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h5><p>为了支持以同样的方式更新信息，并启控制账本所有的功能（交易，查询等），区块链使用 <strong>智能合约</strong> 来提供对账本的受控访问。</p>
<p>智能合约：是一种旨在以信息化方式传播、验证或执行<a href="https://baike.baidu.com/item/合同/20705" target="_blank" rel="noopener">合同</a>的计算机协议。智能合约允许在没有第三方的情况下进行可信交易，这些交易可追踪且不可逆转。</p>
<h4 id="Hyperledger-Fabric-模型"><a href="#Hyperledger-Fabric-模型" class="headerlink" title="Hyperledger Fabric 模型"></a>Hyperledger Fabric 模型</h4>]]></content>
      <categories>
        <category>区块链 - Hyperledger Fabric</category>
      </categories>
      <tags>
        <tag>Hyperledger Fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>解决程序中执行插入语句，mysql数据库表插入的中文变成问号的问题</title>
    <url>/2019/12/08/%E8%A7%A3%E5%86%B3%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%89%A7%E8%A1%8C%E6%8F%92%E5%85%A5%E8%AF%AD%E5%8F%A5%EF%BC%8Cmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E6%8F%92%E5%85%A5%E7%9A%84%E4%B8%AD%E6%96%87%E5%8F%98%E6%88%90%E9%97%AE%E5%8F%B7%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>解决程序中执行插入语句，mysql数据库表插入的中文变成问号的问题</p>
<a id="more"></a>

<p>执行保存操作，执行插入语句<br><img src="https://img-blog.csdnimg.cn/20191208134343121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODg0OTcy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>发现插入的数据，中文在数据库中变成了问号<br><img src="https://img-blog.csdnimg.cn/20191208134506604.png" alt="在这里插入图片描述"><br>在数据库中执行以下插入语句：<br><img src="https://img-blog.csdnimg.cn/20191208134633703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxODg0OTcy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>发现没问题：<br><img src="https://img-blog.csdnimg.cn/20191208134717513.png" alt="在这里插入图片描述"><br>于是检查一下自己的连接配置，发现url中没有加utf-8，于是加上：<br><img src="https://img-blog.csdnimg.cn/20191208134847707.png" alt="在这里插入图片描述"><br>再次执行程序保存操作，发现问题解决：<br><img src="https://img-blog.csdnimg.cn/20191208134937709.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
